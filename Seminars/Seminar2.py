# Task 1. Реализовать чисто структурную реализацию вычисления следа для любой матрицы NxN.
# След матрицы - это сумма чисел на её главной диагонали. След определён только для квадратных матриц
#                (количество столбцов = количеству строк).

matrix = [[8, 5, 4],
          [9, 0, 7],
          [1, 3, 2]]

# Это структурная реализация, поэтому и императивная; не является процедурной, т.к. не объявлена процедура
trace = 0
for i, row in enumerate(matrix):    # так возвращает индекс и сам элемент
    for j, el in enumerate(row):
        if i == j:
            trace += el

print(trace)

# Процедурный вариант этой задачи. Так же это императивный подход. Так же это структурная реализация
def get_trace(matrix):
    trace = 0
    for i, row in enumerate(matrix):  # так возвращает индекс и сам элемент
        for j, el in enumerate(row):
            if i == j:
                trace += el
    return trace

print(get_trace(matrix))

# Task 2. Написать скрипт в любой парадигме, который возвращает полученное число переведенное
# в двоичную систему счисления. Обоснуйте сделанный выбор парадигм.
# Императивная, структурная, процедурная реализация
def decimal_to_binary(decimal):
    binary = ""
    while decimal > 0:
        binary = str(decimal % 2) + binary
        decimal = decimal // 2
    return binary